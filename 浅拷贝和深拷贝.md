## 浅拷贝和深拷贝

#### 1. 浅拷贝

```python
"""浅拷贝"""
"""
   所谓浅拷贝，指的是：对于某个对象，虽然创建了与该对象具有相同值的另一个对象，但是，这两个对象内部嵌套的
对应子对象全都是同一个对象。简单地说，外部进行了拷贝，内部没有拷贝.

   以下方式得到的拷贝都是浅拷贝：
1. 切片操作[:]
2. 调用列表、字典、集合的方法copy()
3. 调用内置函数list()、dict()、set()
4. 调用标准库模块copy中的函数copy()
"""
L1 = [[3, 6], 8]
# L2 = L1[:]
# L2 = L1.copy()
# L2 = list(L1)
import copy       #导入标准库模块copy
L2 = copy.copy(L1)
print(L2)

print('id(L1):%s' % id(L1))            #id(L1):140657564055240
print('id(L2):%s' % id(L2))            #id(L2):140657564072704

print('id(L1[0]):%s' % id(L1[0]))      #id(L1[0]):140657564115024
print('id(L2[0]):%s' % id(L2[0]))      #id(L2[0]):140657564115024

print('id(L1[1]):%s' % id(L1[1]))      #id(L1[1]):17060016
print('id(L2[1]):%s' % id(L2[1]))      #id(L2[1]):17060016


L1[0][1] = 7  //修改可变类型的列表对象
L1[1] = 9    //修改不可变类型的整数对象
print(L1)   #[[3, 7], 9]  
print(L2)   #[[3, 7], 8]
```

> 修改可变类型的对象，L1和L2还是指向同一个对象
>
> 修改不可变类型的对象，是创建了一个新的不可变类型的对象，下图所示



![浅拷贝](pics\浅拷贝.png)



#### 2. 没有嵌套子对象的不可变对象

**对于没有嵌套子对象的不可变对象，例如：整数对象、字符串对象和元祖对象等，不会进行拷贝，也就是说，不会创建另一个对象**

- 浅拷贝下

```python
i = 18

ic1 = int(i)
print(ic1)
print('id(i):%s' % id(i))      #id(i):9721120
print('id(ic1):%s' % id(ic1))  #id(ic1):9721120

ic2 = copy.copy(i)
print(ic2)
print('id(i):%s' % id(i))      #id(i):9721120
print('id(ic2):%s' % id(ic2))  #id(ic2):9721120

t = (1, 2, 3)

tc1 = tuple(t)
print(tc1)
print('id(t):%s' % id(t))      #id(t):140454693167552
print('id(tc1):%s' % id(tc1))  #id(tc1):140454693167552

tc2 = copy.copy(t)
print(tc2)
print('id(t):%s' % id(t))     #id(t):140454693167552
print('id(tc2):%s' % id(tc2)) #id(tc2):140454693167552
```



- 深拷贝下

```python
import copy


i = 18

ic = copy.deepcopy(i)
print(ic)
print('id(i)：%s' % id(i))
print('id(ic)：%s' % id(ic))

t = (1, 2, 3)

tc = copy.deepcopy(t)
print(tc)
print('id(t)：%s' % id(t))
print('id(tc)：%s' % id(tc))
```

> 内存地址也是一样的



通过如上示例，**无论浅拷贝或是深拷贝，对于没有嵌套子对象的不可变对象，都不会创建另一个对象**



#### 3. 深拷贝

```python
"""深拷贝"""
"""
   所谓深拷贝，指的是：对于某个对象，创建与该对象具有相同值的另一个对象，同时，这两个对象
内部嵌套的对应可变子对象全都不是同一个对象。简单地说，外部和内部都进行了拷贝。
"""

L1 = [[3, 6], 8]
L2 = copy.deepcopy(L1)
print(L2)

print('id(L1):%s' % id(L1))        #id(L1):140437660232192
print('id(L2):%s' % id(L2))        #id(L2):140437660232256

print('id(L1[0]):%s' % id(L1[0]))  #id(L1[0]):140437660231552
print('id(L2[0]):%s' % id(L2[0]))  #id(L2[0]):140437660231936

print('id(L1[1]):%s' % id(L1[1]))  #id(L1[1]):9720800
print('id(L2[1]):%s' % id(L2[1]))  #id(L2[1]):9720800,内存地址一样

L1[0][1] = 7
L1[1] = 9
print(L1)     #[[3, 7], 9]
print(L2)     #[[3, 6], 8]
```

> L1和L2的整数8对象的内存地址一致，因为它是“没有嵌套子对象的不可变对象”，下图所示



![深拷贝](pics\深拷贝.png)





**深拷贝-不可变对象内部又嵌套的可变子对象**

```python
"""
   如果不可变对象内部又嵌套的可变子对象，深拷贝之后，会创建一个与该不可变对象具有相同值的另一个对象。
"""
t1 = ([3, 6], 8)
t2 = copy.deepcopy(t1)
print(t2)

print('id(t1):%s' % id(t1))        #id(t1):140645158884224
print('id(t2):%s' % id(t2))        #id(t2):140645158747840

print('id(t1[0]):%s' % id(t1[0]))  #id(t1[0]):140645158914112
print('id(t2[0]):%s' % id(t2[0]))  #id(t2[0]):140645158914240

print('id(t1[1]):%s' % id(t1[1]))  #id(t1[1]):9720800
print('id(t2[1]):%s' % id(t2[1]))  #id(t2[1]):9720800 ，内存地址一样
```

> t1是不可变对象内部嵌套了可变子对象[3,6] , 深拷贝之后，t1和t2不是同一个元组对象。